package "nova/standard"

public class String
{
	visible Int   length
	
	Char[]        data
	
	static Int    whitespaceLength = 4
	static Char[] whitespace       = [ ' ', '\t', '\n', '\r' ]
	
	external void strcpy(char dst[], char src[])
	external void strcat(char dst[], char src[])
	external int strlen(char data[])
	external void memcpy(char dst[], char* src[], int length)
	
	public construct(Char c)
	{
		Char data[] = new Char[2]
		
		data[0] = c
		data[1] = '\0'
		
		this(data)
	}
	
	public construct(Char data[])
	{
		this.data = data
		
		length = calculateLength()
		
//		if (data[length] != '\0')
//		{
//			char newData[] = new char[length + 1]
//			
//			strcpy(newData, data)
//			
//			newData[length] = '\0'
//			
//			this.data = newData
//		}
	}
	
	calculateLength() -> Int
	{
		return strlen(data)
	}
	
	public toCharArray() -> Char[]
	{
		return data
	}
	
	public concat(String str) -> String
	{
		str = str.toString()
		
		Int size = str.length + length + 1
		
		Char newData[] = new Char[size]
		
		strcpy(newData, data)
		strcat(newData, str.toCharArray())
		
		newData[size - 1] = '\0'
		
		String newStr = new String(newData)
		
		return newStr
	}
	
	public equals(String other) -> Bool
	{
		if (length != other.length)
		{
			return false
		}
		
		for (Int i = 0; i < length; i++)
		{
			if (data[i] != other.data[i])
			{
				return false
			}
		}
		
		return true
	}
	
	indexOf(String search, Int start, Int direction) -> Int
	{
		for (Int i = start; i < length && i >= 0; i = i + direction)
		{
			Bool found = true
					
			for (Int j = 0; j < search.length && i + j < length && found; j++)
			{
				if (search.data[j] != data[i + j])
				{
					found = false
				}
			}
			
			if (found)
			{
//				if (direction > 0)
//				{
					return i
//				}
//				else
//				{
//					return i - search.length + 1
//				}
			}
		}
		
		return -1
	}
	
	public indexOf(String search) -> Int
	{
		return indexOf(search, 0, 1)
	}
	
	public indexOf(String search, Int start) -> Int
	{
		return indexOf(search, start, 1)
	}
	
	public lastIndexOf(String search) -> Int
	{
		return indexOf(search, length - 1, -1)
	}
	
	public substring(Int start, Int end) -> String
	{
		if (end - start == 0)
		{
			return ""
		}
		else if (end - start < 0)
		{
			throw new Exception()
		}
		
		Char buf[] = new Char[end - start + 1]
		
		memcpy(buf, data[start], end - start)
		
		buf[end - start] = '\0'
		
		return new String(buf)
	}
	
	public substring(Int start) -> String
	{
		return substring(start, length)
	}
	
	public lastChar() -> Char
	{
		return CharAt(length - 1)
	}
	
	public CharAt(Int index) -> Char
	{
		return data[index]
	}
	
	public trim() -> String
	{
		Int start = 0
		Int end   = length - 1
		
		while (start < length && containsChar(data[start], whitespace, whitespaceLength))
		{
			start++
		}
		
		while (end >= 0 && containsChar(data[end], whitespace, whitespaceLength))
		{
			end--
		}
		
		if (end == 0)
		{
			return ""
		}
		
		if (start == 0 && end == length - 1)
		{
			return this
		}
		
		return substring(start, end + 1)
	}
	
	static containsChar(Char needle, Char Chars[], Int length) -> Bool
	{
		for (Int i = 0; i < length; i++)
		{
			if (needle == Chars[i])
			{
				return true
			}
		}
		
		return false
	}
	
	public toLowerCase() -> String
	{
		return changeCase(Char.toLowerCase)
	}
	
	public toUpperCase() -> String
	{
		return changeCase(Char.toUpperCase)
	}
	
	changeCase(transform(Char) -> Char) -> String
	{
		Char newData[] = new Char[length]
		
		for (Int i = 0; i < length; i++)
		{
			newData[i] = transform(data[i])
		}
		
		return new String(newData)
	}
	
	public getDataBetween(String before, String after) -> String
	{
		return getDataBetween(before, after, 0)
	}
	
	public getDataBetween(String before, String after, Int start) -> String
	{
		Int s = indexOf(before, start)
		Int e = indexOf(after, s + 1)
		
		if (s >= 0 && e > 0)
		{
			return substring(s + before.length, e)
		}
		
		return ""
	}
	
	public toString() -> String
	{
		return this
	}
}