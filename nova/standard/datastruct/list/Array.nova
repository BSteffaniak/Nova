package "nova/standard/datastruct/list"

import "nova/standard/primitive/number/Integer"

public class Array<E> implements List<E>
{
	external void arrayCopy(E dest[], int dIndex, E src[], int sIndex, int len, int destArrLen, int size)
	
	visible Int capacity
	
	visible Int	size
	visible Int position
	
	E[] data
	
	[RequireGenericType E extends String]
	visible String stringsOnly = "hey"
	
	visible Bool empty
	{
		get { return size <= 0 }
		no set
	}
	
	[Override]
	visible ArrayIterator<E> iterator
	{
		get
		{
			return new ArrayIterator(this)
		}
		
		no set
	}
	
	public construct()
	{
		this(10)
	}
	
	public construct(Int size)
	{
	    this.size = 0
	    this.position = 0
	    this.capacity = 0
	    
		increaseSize(size)
	}
	
	public construct(E data[], Int size)
	{
		this(size)
		
		for (Int i = 0; i < size; i++)
		{
			add(data[i])
		}
	}
	
	public add(E element)
	{
		if (position >= capacity)
		{
			increaseSize()
		}
		
		data[position++] = element
		
		size = Math.max(position, size)
	}
	
	public add(Int index, E element)
	{
		if (index >= capacity)
		{
			increaseSize(index + 1)
		}
		
		add(null)
		
		shiftRight(index, position)
		
		data[index] = element
		
		if (index >= position - 1)
		{
			position = index + 1;
		}
		
		size = Math.max(position, size)
	}
	
	public remove(Int index) -> E
	{
		E element = data[index]
		
		shiftLeft(index + 1, position--)
		
		return element
	}
	
	shiftRight(Int left, Int right)
	{
		for (Int i = right - 1; i > left; i--)
		{
			data[i] = data[i - 1]
		}
		
		data[left] = null
	}
	
	shiftLeft(Int left, Int right)
	{
		for (Int i = left - 1; i < right - 1; i++)
		{
			data[i] = data[i + 1]
		}
		
		data[right - 1] = null
	}
	
	public swap(Int index1, Int index2)
	{
		E temp = data[index1]
		data[index1] = data[index2]
		data[index2] = temp
	}
	
	increaseSize()
	{
		increaseSize(capacity + 3)
	}
	
	increaseSize(Int size)
	{
		Int offset = size - capacity
		
		capacity = size
		
		E tmp[] = new E[capacity]
		
		arrayCopy(tmp, 0, data, 0, this.size, capacity, 4)
		
		data = tmp
		
		for (Int i = capacity - offset; i < capacity; i++)
		{
			data[i] = null
		}
	}
	
	public get(Int index) -> E
	{
		return data[index]
	}
	
	public set(Int index, E value)
	{
		data[index] = value
	}
	
	[Override]
	public toArray() -> E[]
	{
		E[] array = new E[size]
		
		for (Int i = 0; i < size; i++)
		{
			array[i] = data[i]
		}

		return array
	}
	
	[Override]
	public map<Out>(mapFunc(E, Int, Array<E>) -> Out) -> Array<Out>
	{
		Array<Out> array = new Array()

		Int i = 0

		for (element in this)
		{
			array.add(mapFunc(element, i++, this))
		}
		
		return array
	}
	
	[Override]
	public forEach(func(E, Int, Array<E>))
	{
		for (Int i = 0; i < size; i++)
		{
			func(data[i], i, this)
		}
	}
	
	[Override]
	public any(anyFunc(E) -> Bool) -> Bool
	{
		for (element in this)
		{
			if (anyFunc(element))
			{
				return true
			}
		}
		
		return false
	}
	
	[Override]
	public all(allFunc(E) -> Bool) -> Bool
	{
		for (element in this)
		{
			if (!allFunc(element))
			{
				return false
			}
		}
		
		return true
	}
	
	[Override]
	public filter(filterFunc(E) -> Bool) -> Array<E>
	{
		Array<E> filtered = new Array()
		
		for (element in this)
		{
			if (filterFunc(element))
			{
				filtered.add(element)
			}
		}
		
		return filtered
	}
	
	[Override]
	public take(Int howMany) -> Array<E>
	{
		if (howMany > size)
		{
			howMany = size
		}
		
		Array<E> list = new Array()
		
		for (Int i = 0; i < howMany; i++)
		{
			list.add(data[i])
		}
		
		return list
	}
	
	[Override]
	public skip(Int howMany) -> Array<E>
	{
		Array<E> list = new Array()
		
		for (Int i = howMany; i < size; i++)
		{
			list.add(data[i])
		}
		
		return list
	}
	
	[Override]
	public first() -> E
	{
		if (size > 0)
		{
			return data[0]
		}
		
		return null
	}
	
	[Override]
	public last() -> E
	{
		if (size > 0)
		{
			return data[size - 1]
		}
		
		return null
	}
	
	[Override]
	public firstWhere(func(E) -> Bool) -> E
	{
		for (element in this)
		{
			if (func(element))
			{
				return element
			}
		}
		
		return null
	}
	
	[RequireGenericType E extends String]
	public sumSize() -> Long
    {
    	Long sum = 0
    	
    	for (value in this)
    	{
    		sum = sum + ((String)value).size
    	}
    	
        return sum
    }
	
	/*[RequireGenericType E extends Integer]
	public sum() -> Long
    {
    	Long sum = 0
    	
    	for (value in this)
    	{
    		sum = sum + (Long)value
    	}
    	
        return sum
    }
	
	[RequireGenericType E extends RealNumber]
	public sum() -> Double
    {
    	Double sum = 0
    	
    	for (value in this)
    	{
    		sum += value
    	}
    	
        return sum
    }*/
    
	[Override]
    public reverse() -> Array<E>
    {
    	Array<E> array = new Array(size)
    	array.size = size
    	
    	Int i = 0
    	
    	for (element in this)
    	{
    		array.data[size - ++i] = element
    	}
    	
    	return array
    }
    
	[Override]
    public join(String delimiter) -> String
    {
    	String str = ""
    	
    	Bool passed = false
    	
    	for (element in this)
    	{
    		if (passed)
    		{
    			str = str + delimiter
    		}
    		else
    		{
    			passed = true
    		}
    		
    		str = str + element.toString()
    	}
    	
    	return str
    }
}